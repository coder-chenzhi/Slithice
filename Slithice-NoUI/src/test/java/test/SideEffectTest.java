package test;

import java.util.*;

import jqian.sootex.location.Location;
import jqian.sootex.location.HeapAbstraction;
import jqian.sootex.ptsto.*;
import jqian.sootex.sideeffect.*;
import soot.*;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;


/**
 */
public class SideEffectTest implements AllTestCases{    
    static void test(ISideEffectAnalysis sideEffect, String methodSignature){
    	SootMethod method = Scene.v().getMethod(methodSignature);
		Test.out.println("\nTesting method: " + method);
		testOnLocations(sideEffect, method);
    }   
    
    static void testOnLocations(ISideEffectAnalysis sideEffect,SootMethod m){
         Collection<Location> modLocs = sideEffect.getModHeapLocs(m);        
         Test.out.print("\nModification set: ");
         Test.printCollection(modLocs.iterator(),"\n");   
    	   
         Collection<Location> useLocs = sideEffect.getUseHeapLocs(m);        
         Test.out.print("\nUse set: ");
         Test.printCollection(useLocs.iterator(),"\n");

         Collection<Location> modGlobalLocs = sideEffect.getModGlobals(m);
         Test.out.print("\nModified gloal set: ");
         Test.printCollection(modGlobalLocs.iterator(),"\n");

         Collection<Location> useGlobalLocs = sideEffect.getUseGlobals(m);
         Test.out.print("\nUsed gloal set: ");
         Test.printCollection(useGlobalLocs.iterator(),"\n");
    }   
    
	@SuppressWarnings({ "rawtypes" })
	public static ISideEffectAnalysis loadSideEffector(){
        IPtsToQuery query = new SparkPtsToQuery();
		//GlobalPtsToQuery query = new GlobalPtsToQuery.Default(NaivePtsToQuery.v());
//		IPtsToQuery query = new TypeBasedPtsToQuery(false);
		//SootMethod e = Scene.v().getEntryPoints().get(0);
    	//Collection entries = new LinkedList();
    	//entries.add(e);
		Collection entries = Scene.v().getEntryPoints();
		HeapAbstraction opt = HeapAbstraction.FIELD_SENSITIVE;
		//MemoryDistinguishment opt = MemoryDistinguishment.FIELD_BASED;
		//MemoryDistinguishment opt = MemoryDistinguishment.TYPE_BASED;
		//MemoryDistinguishment opt = MemoryDistinguishment.NO_DISTINGUISH;
    	SideEffectAnalysis se = new SideEffectAnalysis(query,entries, opt);
    	se.build();
    	return se;
	}

    public static Collection<SootMethod> widthFirstDumpCallGraph(CallGraph cg, SootMethod entry, int depth){
        Queue<SootMethod> queue = new LinkedList<SootMethod>();
        queue.add(entry);
        Set<SootMethod> processed = new HashSet<SootMethod>();

        for(int i=0; i<depth && !queue.isEmpty(); i++){
            // process elements generated by last round
            int size = queue.size();

            for(int k=0;k<size;k++){
                SootMethod m = (SootMethod)queue.poll();

                if(!processed.add(m)){
                    continue;
                }

                System.out.println("Source: " + m.toString());
                for(Iterator<Edge> it = cg.edgesOutOf(m); it.hasNext();){
                    Edge e = it.next();

                    SootMethod tgt = e.tgt();
                    System.out.println("\t--> " + tgt.toString());
                    if(!processed.contains(tgt)){
                        queue.offer(tgt);
                    }
                }
            }
        }

        return processed;
    }
    
    
    public static void main(String[] args) {
    	Test.loadConfig("../config.xml");
    	Test.loadClasses(true);
    	
    	//SootUtils.doSparkPointsToAnalysis(Collections.EMPTY_MAP);
    	Test.doFastSparkPointsToAnalysis();

    	SideEffectTest.widthFirstDumpCallGraph(Scene.v().getCallGraph(), Scene.v().getMethod("<test.cases.SideEffect: void main(java.lang.String[])>"), 10000);

    	//ISideEffector sideEffect = Test.loadSideEffector();
    	ISideEffectAnalysis sideEffect = loadSideEffector();
//    	String method = SideEffect.SIDE_EFFECT_CASES[0];
    	String method = SideEffect.MY_CASES[1];
    	test(sideEffect, method); 
    }
}

